<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Constructor functions for smooth terms in a GAM</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for smooth.construct {mgcv}"><tr><td>smooth.construct {mgcv}</td><td align="right">R Documentation</td></tr></table>
<h2>Constructor functions for smooth terms in a GAM</h2>


<h3>Description</h3>

<p>
Smooth terms in a GAM formula are turned into smooth specification objects of 
class <code>xx.smooth.spec</code> during processing of the formula. Each of these objects is
converted to a smooth object using an appropriate <code>smooth.construct</code> function. New smooth classes 
can be added by writing a new <code>smooth.construct</code> method function and a corresponding 
<code><a href="Predict.matrix.html">Predict.matrix</a></code> method function (see example code below).
</p>
<p>
In practice, <code>smooth.construct</code> is usually called via <code>smooth.construct2</code> and the wrapper
function <code><a href="smoothCon.html">smoothCon</a></code>, in order to handle <code>by</code> variables and
centering constraints (see the <code><a href="smoothCon.html">smoothCon</a></code> documentation if 
you need to handle these things directly, for a user defined smooth class).
</p>


<h3>Usage</h3>

<pre>
smooth.construct(object,data,knots)
smooth.construct2(object,data,knots)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>object</code></td>
<td>
is a smooth specification object, generated by an <code><a href="s.html">s</a></code> or <code><a href="te.html">te</a></code> term in a GAM 
formula. Objects generated by <code>s</code> terms have class <code>xx.smooth.spec</code> where <code>xx</code> is given by the 
<code>bs</code> argument of <code>s</code> (this convention allows the user to add their own smoothers). 
If <code>object</code> is not class <code>tensor.smooth.spec</code> it will have the following elements:
<br>
<ul>
<dt>term</dt><dd>The names of the covariates for this smooth, in an array.</dd>
<dt>bs.dim</dt><dd>Argument <code>k</code> of the <code>s</code> term generating the object. This is the dimension of the basis 
used to represent the term (or, arguably, 1 greater than the basis dimension for <code>cc</code> terms). 
<code>bs.dim&lt;0</code> indicates that the constructor should set this to the default value.</dd>
<dt>fixed</dt><dd><code>TRUE</code> if the term is to be unpenalized, otherwise <code>FALSE</code>.</dd>
<dt>dim</dt><dd>the number covariates of which this smooth is a function.</dd>
<dt>p.order</dt><dd>the order of the smoothness penalty or <code>NA</code> for autoselection of this. This is argument 
<code>m</code> of the <code>s</code> term that generated <code>object</code>.</dd>
<dt>by</dt><dd>the name of any <code>by</code> variable to multiply this term as supplied as an argument to <code>s</code>. 
<code>"NA"</code> if there is no such term.</dd>
<dt>label</dt><dd>A suitable label for use with this term.</dd>
<dt>xt</dt><dd>An object containing information that may be needed for basis setup
(used, e.g. by <code>"tp"</code> smooths to pass optional information on big dataset
handling).</dd>
<dt>id</dt><dd>Any identity associated with this term &mdash; used for linking bases
and smoothing parameters. <code>NULL</code> by default, indicating no linkage.</dd>
<dt>sp</dt><dd>Smoothing parameters for the term. Any negative are estimated,
otherwise they are fixed at the supplied value. Unless <code>NULL</code> (default),
over-rides <code>sp</code> argument to <code><a href="gam.html">gam</a></code>.</dd>
</ul>
<br>
If <code>object</code> is of class <code>tensor.smooth.spec</code> then it was generated by a <code>te</code> term in the GAM formula, 
and specifies a smooth of several variables with a basis generated as a tensor product of lower dimensional bases. 
In this case the object will be different and will have the following elements:
<ul>
<dt>margin</dt><dd>is a list of smooth specification objects of the type listed above, defining the bases which have 
their tensor product formed in order to construct this term.</dd>
<dt>term</dt><dd>is the array of names of the covariates that are arguments of the smooth.</dd>
<dt>by</dt><dd>is the name of any <code>by</code> variable, or <code>"NA"</code>.</dd>
<dt>fx</dt><dd>is an array, the elements of which indicate whether (<code>TRUE</code>) any of the margins in the 
tensor product should be unpenalized.</dd>
<dt>label</dt><dd>A suitable label for use with this term.</dd>
<dt>dim</dt><dd>is the number of covariates of which this smooth is a function.</dd>
<dt>mp</dt><dd><code>TRUE</code> if multiple penalties are to be used.</dd>
<dt>np</dt><dd><code>TRUE</code> if 1-D marginal smooths are to be re-parameterized in terms of
function values.</dd>
<dt>id</dt><dd>Any identity associated with this term &mdash; used for linking bases
and smoothing parameters. <code>NULL</code> by default, indicating no linkage.</dd>
<dt>sp</dt><dd>Smoothing parameters for the term. Any negative are estimated,
otherwise they are fixed at the supplied value. Unless <code>NULL</code> (default),
over-rides <code>sp</code> argument to <code><a href="gam.html">gam</a></code>.</dd>
</ul></td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
For <code>smooth.construct</code> a data frame or list containing the evaluation of the elements of <code>object$term</code>,
with names given by <code>object$term</code>. The last entry will be the <code>by</code> variable, if <code>object$by</code>
is not <code>"NA"</code>. For <code>smooth.construct2</code> <code>data</code> need only be an object within which <code>object$term</code> 
can be evaluated, the variables can be in any order, and there can be irrelevant variables present as well. </td></tr>
<tr valign="top"><td><code>knots</code></td>
<td>
an optional data frame or list containing the knots relating to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically. The structure of <code>knots</code> should
be as for <code>data</code>, depending on whether <code>smooth.construct</code> or <code>smooth.construct2</code> is used.</td></tr>
</table>

<h3>Details</h3>

<p>
There are built in methods for objects with the following classes:
<code>tp.smooth.spec</code> (thin plate regression splines: see <code><a href="smooth.construct.tp.smooth.spec.html">tprs</a></code>); 
<code>ts.smooth.spec</code> (thin plate regression splines with shrinkage-to-zero);
<code>cr.smooth.spec</code> (cubic regression splines: see <code><a href="smooth.construct.cr.smooth.spec.html">cubic.regression.spline</a></code>;
<code>cs.smooth.spec</code> (cubic regression splines with shrinkage-to-zero);
<code>cc.smooth.spec</code> (cyclic cubic regression splines);
<code>ps.smooth.spec</code> (Eilers and Marx (1986) style P-splines: see <code><a href="smooth.construct.ps.smooth.spec.html">p.spline</a></code>);
<code>cp.smooth.spec</code> (cyclic P-splines)
<code>ad.smooth.spec</code> (adaptive smooths of 1 or 2 variables: see <code><a href="smooth.construct.ad.smooth.spec.html">adaptive.smooth</a></code>);
<code>tensor.smooth.spec</code> (tensor product smooths).
</p>
<p>
There is an implicit assumption that the basis only depends on the knots and/or the set of unique 
covariate combinations; i.e. that the basis is the same whether generated from
the full set of covariates, or just the unique combinations of covariates.
</p>


<h3>Value</h3>

<p>
The input argument <code>object</code>, assigned a new class to indicate what type of smooth it is and with at least the 
following items added:
</p>
<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
The model matrix from this term. This may have an <code>"offset"</code>
attribute:  a vector of length <code>nrow(X)</code> containing any contribution of
the smooth to the model offset term. <code>by</code> variables do not need to be
dealt with here, but if they are then an item <code>by.done</code> must be added to
the <code>object</code>.</td></tr>
<tr valign="top"><td><code>S</code></td>
<td>
A list of positive semi-definite penalty matrices that apply to this term. The list will be empty 
if the term is to be left un-penalized.</td></tr>
<tr valign="top"><td><code>rank</code></td>
<td>
an array giving the ranks of the penalties.</td></tr>
<tr valign="top"><td><code>C</code></td>
<td>
The matrix defining any constraints on the term. If this is <code>NULL</code> then
<code>smoothCon</code> will add an identifiability constraint that each term should
sum to zero over the covariate values. Set to a zero row matrix if no
constraints are required. Note that a supplied <code>C</code> is never ignored, even if any
<code>by</code> variables of a smooth imply that no constraint is actually needed. </td></tr>
<tr valign="top"><td><code>df</code></td>
<td>
the degrees of freedom associated with this term (when
unpenalized and unconstrained). If this is null then <code>smoothCon</code> will set it to the basis 
dimension. <code>smoothCon</code> will reduce this by the number of constraints.</td></tr>
<tr valign="top"><td><code>L</code></td>
<td>
smooths may depend on fewer `underlying' smoothing parameters than there are elements of
<code>S</code>. In this case <code>L</code> is the matrix mapping the vector of underlying log smoothing 
parameters to the vector of logs of the smoothing parameters actually multiplying the <code>S[[i]]</code>. 
<code>L=NULL</code> signifies that there is one smoothing parameter per <code>S[[i]]</code>. </td></tr>
</table>
<p>

<br>
Usually the returned object will also include extra information required to define the basis, and used by 
<code><a href="Predict.matrix.html">Predict.matrix</a></code> methods to make predictions using the basis. See
the <code>Details</code> section for links to the information included for the built in smooth classes. 
<br>
<code>tensor.smooth</code> returned objects will additionally have each element of
the <code>margin</code> list updated in the same way. <code>tensor.smooths</code> also
have a list, <code>XP</code>, containing re-parameterization matrices for any 1-D marginal terms
re-parameterized in terms of function values. This list will have <code>NULL</code>
entries for marginal smooths that are not re-parameterized, and is only long
enough to reach the last re-parameterized marginal in the list.</p>

<h3>WARNING</h3>

<p>
User defined smooth objects should avoid having attributes names
<code>"qrc"</code> or <code>"nCons"</code> as these are used internally to provide
constraint free parameterizations.
</p>


<h3>Author(s)</h3>

<p>
Simon N. Wood <a href="mailto:simon.wood@r-project.org">simon.wood@r-project.org</a>
</p>


<h3>References</h3>

<p>
Wood, S.N. (2003) Thin plate regression splines. J.R.Statist.Soc.B 65(1):95-114
</p>
<p>
Wood, S.N. (2006) Low rank scale invariant tensor product smooths for
generalized additive mixed models. Biometrics 62(4):1025-1036
</p>
<p>
The P-spline code given in the example is based on those advocated in:
</p>
<p>
Ruppert, D., M.P. Wand and R.J. Carroll (2003) Semiparametric Regression. Cambridge 
University Press.
</p>
<p>
However if you want p-splines, rather than splines with derivative based penalties,
then the built in "ps" class is probably a better bet. It's based on
</p>
<p>
Eilers, P.H.C. and B.D. Marx (1996) Flexible Smoothing with B-splines and Penalties. 
Statistical Science, 11(2):89-121
</p>
<p>
<a href="http://www.maths.bath.ac.uk/~sw283/">http://www.maths.bath.ac.uk/~sw283/</a>
</p>


<h3>See Also</h3>

<p>
<code><a href="s.html">s</a></code>,<code><a href="get.var.html">get.var</a></code>, <code><a href="gamm.html">gamm</a></code>, <code><a href="gam.html">gam</a></code>,
<code><a href="Predict.matrix.html">Predict.matrix</a></code>,
<code><a href="smoothCon.html">smoothCon</a></code>, <code><a href="smoothCon.html">PredictMat</a></code>
</p>


<h3>Examples</h3>

<pre># adding "p-spline" classes and methods

smooth.construct.tr.smooth.spec&lt;-function(object,data,knots)
## a truncated power spline constructor method function
## object$p.order = null space dimension
{ m &lt;- object$p.order[1]
  if (is.na(m)) m &lt;- 2 ## default 
  if (m&lt;1) stop("silly m supplied")
  if (object$bs.dim&lt;0) object$bs.dim &lt;- 10 ## default
  nk&lt;-object$bs.dim-m-1 ## number of knots
  if (nk&lt;=0) stop("k too small for m")
  x &lt;- data[[object$term]]  ## the data
  x.shift &lt;- mean(x) # shift used to enhance stability
  k &lt;- knots[[object$term]] ## will be NULL if none supplied
  if (is.null(k)) # space knots through data
  { n&lt;-length(x)
    k&lt;-quantile(x[2:(n-1)],seq(0,1,length=nk+2))[2:(nk+1)]
  }
  if (length(k)!=nk) # right number of knots?
  stop(paste("there should be ",nk," supplied knots"))
  x &lt;- x - x.shift # basis stabilizing shift
  k &lt;- k - x.shift # knots treated the same!
  X&lt;-matrix(0,length(x),object$bs.dim)
  for (i in 1:(m+1)) X[,i] &lt;- x^(i-1)
  for (i in 1:nk) X[,i+m+1]&lt;-(x-k[i])^m*as.numeric(x&gt;k[i])
  object$X&lt;-X # the finished model matrix
  if (!object$fixed) # create the penalty matrix
  { object$S[[1]]&lt;-diag(c(rep(0,m+1),rep(1,nk)))
  }
  object$rank&lt;-nk  # penalty rank
  object$null.space.dim &lt;- m+1  # dim. of unpenalized space
  ## store "tr" specific stuff ...
  object$knots&lt;-k;object$m&lt;-m;object$x.shift &lt;- x.shift
  ## get the centering constraint ...
 
  object$df&lt;-ncol(object$X)     # maximum DoF (if unconstrained)
 
  class(object)&lt;-"tr.smooth"  # Give object a class
  object
}

Predict.matrix.tr.smooth&lt;-function(object,data)
## prediction method function for the `tr' smooth class
{ x &lt;- data[[object$term]]
  x &lt;- x - object$x.shift # stabilizing shift
  m &lt;- object$m;     # spline order (3=cubic)
  k&lt;-object$knots    # knot locations
  nk&lt;-length(k)      # number of knots
  X&lt;-matrix(0,length(x),object$bs.dim)
  for (i in 1:(m+1)) X[,i] &lt;- x^(i-1)
  for (i in 1:nk) X[,i+m+1] &lt;- (x-k[i])^m*as.numeric(x&gt;k[i])
  X # return the prediction matrix
}


# an example, using the new class....
set.seed(100)
dat &lt;- gamSim(1,n=400,scale=2)
b&lt;-gam(y~s(x0,bs="tr",m=2)+s(x1,bs="ps",m=c(1,3))+
         s(x2,bs="tr",m=3)+s(x3,bs="tr",m=2),data=dat)
plot(b,pages=1)
b&lt;-gamm(y~s(x0,bs="tr",m=2)+s(x1,bs="ps",m=c(1,3))+
         s(x2,bs="tr",m=3)+s(x3,bs="tr",m=2),data=dat)
plot(b$gam,pages=1)
# another example using tensor products of the new class
dat &lt;- gamSim(2,n=400,scale=.1)$data
b &lt;- gam(y~te(x,z,bs=c("tr","tr"),m=c(2,2)),data=dat)
vis.gam(b)
</pre>



<hr><div align="center">[Package <em>mgcv</em> version 1.4-1 <a href="00Index.html">Index]</a></div>

</body></html>
